#include <SPI.h>
#include "SdFat.h"
#include "FreeStack.h"
#include <Wire.h>
#include "MPU6050.h"
#include "I2Cdev.h"

#define mpuInterruptPin   2
const uint8_t sdCardCSpin = 8;
const char fileName [] = "data.bin";

#define error(s) sd.errorHalt(F(s))

void sdCardInit (void);
void mpu6050Init  (void);
void mpuDataReadyIRQ  (void);
void writeBufferToFile  (void);
void writeBufferToSDcard  (void);

MPU6050 accelgyro;

SdFat sd;
SdFile file;

//const uint16_t bufferSize = 512;
//uint8_t sdWriteBuffer [bufferSize];

uint8_t * dataBuffer;

void setup()
{
    //TIMSK0 = 0; //disable timer 0 with millis
    Serial.begin(115200);
    Serial.println("Power up");
    delay(10);
    sdCardInit();
    Wire.begin(); //for i2c
    mpu6050Init();
    interrupts();
}



void sdCardInit (void)
{
  uint32_t bgnBlock, endBlock;
  uint32_t freeSpaceOnCard;
  
  Serial.println("Initializing SD card");
  
  if (!sd.begin(sdCardCSpin, SPI_FULL_SPEED))
  {
    sd.initErrorHalt();
  }
  Serial.println("card initialized.");
  
  sd.remove(fileName);    //delete in final
  freeSpaceOnCard = sd.freeClusterCount() * sd.blocksPerCluster() * 512;
  freeSpaceOnCard = 1048576;
  Serial.println(sd.freeClusterCount());
  if (!file.createContiguous(sd.vwd(), fileName, freeSpaceOnCard))
  {
    Serial.println("createContiguous failed");
  }
  Serial.println(sd.freeClusterCount());
  if (!file.contiguousRange(&bgnBlock, &endBlock))
  {
    Serial.println("contiguousRange failed");
  }

  dataBuffer = (uint8_t*)sd.vol()->cacheClear();
  memset(dataBuffer, '-', 512);
  if (!sd.card()->writeStart(bgnBlock, freeSpaceOnCard/512))
  {
    Serial.println("writeStart failed");
  }
  char writeStart [] = "start";
  memcpy(&dataBuffer[0], writeStart, sizeof(writeStart));
  
  writeBufferToSDcard();
  Serial.println("end");
  while(false)
  {}
}

void mpu6050Init (void)
{
  Serial.println("MPU init");
  accelgyro.initialize();
  Serial.println("MPU configuring");
  accelgyro.setDLPFMode(1);           //set low-pass filter for gyro and acc 188Hz (maximum)
  accelgyro.setRate(1);               //set 500Hz for acelerometer
  accelgyro.setInterruptMode(1);      //set interrupt active low
  accelgyro.setInterruptDrive(MPU6050_INTDRV_PUSHPULL);   //set interrupt output to push-pull
  accelgyro.setInterruptLatch(MPU6050_INTLATCH_50USPULSE);      //set interrupt only for 50us
  accelgyro.setInterruptLatchClear(true);             //clear interrupt register at any read operation
  accelgyro.setIntMotionEnabled(false);               //disable motion interrupt
  accelgyro.setIntZeroMotionEnabled(false);           //disable zero gravity interrupt
  accelgyro.setIntDataReadyEnabled(true);             //ENABLE data ready interrupt
  accelgyro.setIntI2CMasterEnabled(false);            //disable i2c interrupt
  accelgyro.setIntFIFOBufferOverflowEnabled(false);   //disable FIFO overflow interrupt
  accelgyro.setFIFOEnabled(false);                    //disable FIFO, totaly
  accelgyro.setI2CMasterModeEnabled(false);           //disable i2c master
  Serial.println("Testing device connections...");
  Serial.println(accelgyro.testConnection() ? "MPU6050 OK!" : "MPU6050 connection failed!!!");
  delay(5);
  noInterrupts();
  pinMode(mpuInterruptPin, INPUT); //mpu interrupt init
  attachInterrupt(0, mpuDataReadyIRQ, FALLING);
  
}

const uint8_t accSize = 2;
const uint8_t mpuTempSize = 2;
const uint8_t gyroSize = 2;
const uint8_t mpuDataSize = 3*accSize + 3*gyroSize + mpuTempSize;
const uint8_t bmpTempSize = 2;          //TODO
const uint8_t pressureSize = 2; 
const uint8_t bmpDataSize = bmpTempSize + pressureSize;
const uint8_t millisSize = 4;
const uint8_t batteryChargeSize = 1;
const uint8_t fusesStateSize = 1;
const uint8_t radioStateSize = 1;
const uint8_t measureNumSize = 4;
const uint8_t endSize = 3;
const uint8_t singleMeasureSize = mpuDataSize + bmpDataSize + millisSize + batteryChargeSize + fusesStateSize + radioStateSize + measureNumSize + endSize;

const char endOfMeasureSymbol = ';';

volatile int16_t ax, ay, az;
volatile int16_t gx, gy, gz;
volatile uint32_t measureNum = 0;
volatile uint8_t toSend [singleMeasureSize];
//volatile bool newMpuDataInBuf = false;
//volatile bool readComplete;
//volatile bool lastReadComplete = true;

volatile uint8_t bufferOffset = 0;
volatile bool bufferFull = false;

const uint8_t queueSize = 1;
volatile uint8_t queueBuffer [singleMeasureSize * queueSize];
volatile bool queueBufferUsed = false;

void mpuDataReadyIRQ (void)
{  
  EIMSK = 0;
  measureNum++;
  interrupts();
  I2Cdev::readBytes(MPU6050_DEFAULT_ADDRESS, MPU6050_RA_ACCEL_XOUT_H, 14, toSend);
  
  toSend[14] = 't';
  toSend[15] = 't';
  toSend[16] = 'p';
  toSend[17] = 'p';
  memset(&toSend[18], ';', 14);
  memcpy(&toSend [25], &measureNum, measureNumSize);

  if (!bufferFull)
  {
    if (queueBufferUsed)
    {
      memcpy(&dataBuffer [0], toSend, bufferOffset * singleMeasureSize);
      queueBufferUsed = false;
    }
    memcpy(&dataBuffer [bufferOffset * singleMeasureSize], queueBuffer, bufferOffset);
  }
  else
  {
    if (bufferOffset > queueSize)
    {
      Serial.println("queueBuffer overloaded!!!!");
      while(true)
      {}
    }
    queueBufferUsed = true;
    memcpy(&queueBuffer [bufferOffset * singleMeasureSize], toSend, singleMeasureSize);
  }
  
  bufferOffset++;
  if (bufferOffset > 15)
  {
    bufferOffset = 0;
    bufferFull = true;
  }
  //newMpuDataInBuf = true;
  EIMSK = 1;
}

void loop() {  
  //delay(100);
  //noInterrupts();
  //uint16_t localCounter = counter;
  //Serial.println('1');
  //interrupts();

  
  //Serial.println (lastreadComplete);
  if (bufferFull)
  {
    Serial.print ('s');
    writeBufferToSDcard();
    bufferFull = false;
    Serial.print ('w');
  }
  
  /*
  if (localCounter >= 30)
  {
    
    //Serial.print(" lC:");
    //Serial.println(counter);
    
    //noInterrupts();
    //counter = 0;
    //interrupts();
    //file.sync();
    //file.close();
  }  
  */
}
void writeBufferToSDcard  (void)
{
  if (!sd.card()->writeData(dataBuffer))
  {
    Serial.println("writeData failed");
  }
}
